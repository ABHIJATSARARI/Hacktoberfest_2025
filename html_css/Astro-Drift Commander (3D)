<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro-Drift Commander (3D)</title>
    <!-- Load Tailwind CSS CDN for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Load Orbitron font for arcade look -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    </style>
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Orbitron', 'sans-serif'],
                    },
                    colors: {
                        'space-dark': '#0a0a20',
                        'ship-color': '#3b82f6',
                        'gate-color': '#10b981', 
                        'highlight': '#fcd34d',
                    }
                }
            }
        }
    </script>
    <!-- Custom Game CSS -->
    <style>
        /* Base styles */
        body {
            background-color: #0a0a20; 
            color: #fcd34d; 
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none; /* Control input via JS */
        }

        /* Canvas Container */
        #game-container {
            width: 95%;
            max-width: 600px;
            aspect-ratio: 16 / 9; /* Wider aspect for a 3D view */
            margin: 1rem auto;
            border: 5px solid #3b82f6;
            box-shadow: 0 0 40px rgba(59, 130, 246, 0.9); 
            border-radius: 12px;
            overflow: hidden;
            background-color: #0a0a20; 
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: move;
        }

        /* Button styling */
        .game-button {
            font-size: 1rem;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border: 2px solid #a855f7;
            background: #1f2937;
            color: #a855f7;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
            transition: all 0.15s ease-in-out;
            font-weight: 700;
        }

        .game-button:hover:not(:disabled) {
            background: #a855f7;
            color: #0f172a;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.6);
        }

        .game-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .game-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center min-h-screen">

    <div class="w-full max-w-4xl flex flex-col items-center">
        <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-gate-color tracking-wider text-shadow-xl text-center">
            ðŸš€ ASTRO-DRIFT COMMANDER ðŸŒŒ (3D)
        </h1>

        <!-- Stats Display -->
        <div class="w-full max-w-[600px] flex justify-between text-lg sm:text-xl font-mono p-3 rounded-lg bg-gray-800 border-2 border-gray-700 shadow-lg mb-4">
            <span>GATES: <span id="score-display" class="text-highlight">0</span></span>
            <span>SPEED: <span id="speed-display" class="text-ship-color">1.0x</span></span>
        </div>

        <!-- Controls -->
        <div class="flex space-x-4 mb-4">
            <button id="start-button" class="game-button rounded-full">
                Engage Warp
            </button>
            <button id="stop-button" class="game-button rounded-full hidden bg-red-800 border-red-500 text-red-300 hover:bg-red-500 hover:text-white" disabled>
                Emergency Stop
            </button>
        </div>

        <!-- Game Container -->
        <div id="game-container">
            <div id="game-canvas"></div>
        </div>
        
        <!-- Status Message -->
        <div class="w-full max-w-[600px] text-center mt-4">
            <p id="status-display" class="text-lg font-bold text-highlight">Ready for 3D simulation.</p>
            <p class="text-xs text-gray-500 mt-1">Use your **mouse/touch** to drag the ship and steer through the gates.</p>
        </div>

        <!-- Game Over / Start Message Modal -->
        <div id="message-modal" class="hidden fixed inset-0 bg-space-dark bg-opacity-90 z-20 items-center justify-center" onclick="hideMessage()">
            <div class="bg-gray-800 p-8 rounded-xl shadow-2xl border-4 border-highlight max-w-md w-full mx-4" onclick="event.stopPropagation()">
                <h2 id="modal-title" class="text-3xl font-bold mb-4 text-highlight">Welcome Commander</h2>
                <p id="modal-message" class="text-gray-300 mb-6 text-lg">Pilot your ship through the energy gates without touching the rings! Speed increases with score.</p>
                
                <button class="game-button rounded-lg w-full" onclick="hideMessage()">Start Simulation</button>
            </div>
        </div>

        <!-- Signature/Credit -->
        <p class="text-xs text-gray-500 mt-6 tracking-widest uppercase">
            Code Signature: abhijat sarari
        </p>
    </div>

    <!-- JavaScript Game Logic (Three.js) -->
    <script>
        // --- Three.js Globals ---
        let scene, camera, renderer;
        let ambientLight, directionalLight;
        let ship;
        const gateContainer = new THREE.Group();
        const gates = [];
        let canvasContainer;

        // --- Game State Variables ---
        let score = 0;
        let gameSpeed = 0.5; // Base speed for gates moving towards camera
        let isGameRunning = false;
        let animationFrameId = null;
        let mouse = { x: 0, y: 0 };
        let targetShipPosition = { x: 0, y: 0 };

        let gateSpawnDistance = -50; // Initial Z distance where gates are spawned
        let spawnInterval = 3000; // Time in ms between spawns
        let lastSpawnTime = 0;
        const Z_DESTROY = 10;
        const BOUNDARY = 10;
        const SHIP_Z = 5;

        // --- Tone.js Setup ---
        let moveSynth, collisionSynth, scoreSynth;
        
        function initAudio() {
            try {
                if (!moveSynth) {
                    Tone.start();
                    moveSynth = new Tone.PluckSynth().toDestination();
                    
                    collisionSynth = new Tone.NoiseSynth({ 
                        noise: { type: "white" }, 
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.5 } 
                    }).toDestination();
                    
                    scoreSynth = new Tone.Synth({ 
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0 } 
                    }).toDestination();
                }
            } catch (e) {
                console.error("Tone.js failed to initialize:", e);
            }
        }

        function playMoveSound() { if (moveSynth) { moveSynth.triggerAttackRelease("A4", "16n"); } }
        function playCollisionSound() { if (collisionSynth) { collisionSynth.triggerAttackRelease("8n"); } }
        function playScoreSound() { if (scoreSynth) { scoreSynth.triggerAttackRelease("C5", "16n"); } }

        // --- Three.js Initialization and Setup ---

        function init3D() {
            canvasContainer = document.getElementById('game-canvas');
            
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a20, 1, 100); 

            // Camera (FOV, Aspect Ratio, Near, Far)
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 100);
            camera.position.z = SHIP_Z;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setClearColor(0x0a0a20);
            canvasContainer.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0x404040, 3); // Soft white light
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // Background Stars (Particle System)
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 5000;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200; // X
                positions[i * 3 + 1] = (Math.random() - 0.5) * 200; // Y
                positions[i * 3 + 2] = -Math.random() * 100; // Z
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, sizeAttenuation: true });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            // Ship (A simple blue tetrahedron)
            const shipGeometry = new THREE.TetrahedronGeometry(0.5);
            const shipMaterial = new THREE.MeshPhongMaterial({ color: 0x3b82f6, emissive: 0x3b82f6, emissiveIntensity: 0.5 });
            ship = new THREE.Mesh(shipGeometry, shipMaterial);
            ship.position.z = SHIP_Z;
            ship.rotation.x = Math.PI / 8; 
            scene.add(ship);
            
            // Gates container
            scene.add(gateContainer);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', handleMouseMove);
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            onWindowResize(); // Initial resize
        }

        function onWindowResize() {
            if (!canvasContainer || !camera || !renderer) return;

            // Update aspect ratio
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        // --- Input Handling ---

        function normalizeCoordinates(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            // Normalize X and Y to -1 to 1 range
            let x = (clientX - rect.left) / rect.width * 2 - 1;
            let y = -(clientY - rect.top) / rect.height * 2 + 1;
            return { x, y };
        }

        function handleMouseMove(event) {
            mouse = normalizeCoordinates(event.clientX, event.clientY);
            if (isGameRunning) {
                // Map the normalized mouse coordinates to the scene's playable BOUNDARY
                targetShipPosition.x = mouse.x * BOUNDARY * 0.8;
                targetShipPosition.y = mouse.y * BOUNDARY * 0.6;
                // Add a slight tilt for visual effect
                ship.rotation.z = -mouse.x * 0.5;
                ship.rotation.y = -mouse.x * 0.2;
            }
        }
        
        function handleTouchMove(event) {
            if (event.touches.length > 0) {
                event.preventDefault(); // Prevent scrolling
                const touch = event.touches[0];
                mouse = normalizeCoordinates(touch.clientX, touch.clientY);
                if (isGameRunning) {
                    targetShipPosition.x = mouse.x * BOUNDARY * 0.8;
                    targetShipPosition.y = mouse.y * BOUNDARY * 0.6;
                    ship.rotation.z = -mouse.x * 0.5;
                    ship.rotation.y = -mouse.x * 0.2;
                }
            }
        }

        // --- Gate Management ---

        function createGate() {
            // Gate properties
            const gateWidth = 8;
            const gateHeight = 8;
            const gateThickness = 0.2;
            const holeSize = 3; 

            const color = new THREE.Color(0x10b981);
            const material = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });

            // Create four bars for the ring: Top, Bottom, Left, Right
            const geometryH = new THREE.BoxGeometry(gateWidth, gateThickness, gateThickness);
            const geometryV = new THREE.BoxGeometry(gateThickness, gateHeight - gateThickness * 2, gateThickness);

            // Top Bar
            const topBar = new THREE.Mesh(geometryH, material);
            topBar.position.y = gateHeight / 2;

            // Bottom Bar
            const bottomBar = new THREE.Mesh(geometryH, material);
            bottomBar.position.y = -gateHeight / 2;

            // Left Bar
            const leftBar = new THREE.Mesh(geometryV, material);
            leftBar.position.x = -gateWidth / 2;

            // Right Bar
            const rightBar = new THREE.Mesh(geometryV, material);
            rightBar.position.x = gateWidth / 2;

            // Group the bars
            const gateMesh = new THREE.Group();
            gateMesh.add(topBar, bottomBar, leftBar, rightBar);
            
            // Randomly offset the gate's center position (within bounds)
            const offsetX = (Math.random() - 0.5) * (BOUNDARY * 2 - gateWidth);
            const offsetY = (Math.random() - 0.5) * (BOUNDARY * 2 - gateHeight);
            
            gateMesh.position.set(offsetX, offsetY, gateSpawnDistance);
            gateMesh.rotation.z = Math.random() * Math.PI; // Random initial rotation
            
            gateContainer.add(gateMesh);
            gates.push({
                mesh: gateMesh,
                holeRect: { 
                    x: offsetX, 
                    y: offsetY, 
                    width: holeSize * 2, 
                    height: holeSize * 2 
                },
                passed: false // Flag to track if the ship passed through it
            });
        }

        function updateGates() {
            // Speed up based on score
            gameSpeed = 0.5 + Math.floor(score / 5) * 0.1;
            
            // Move gates towards the camera (Z-axis)
            for (let i = gates.length - 1; i >= 0; i--) {
                const gate = gates[i];
                gate.mesh.position.z += gameSpeed;
                gate.mesh.rotation.x += 0.005; // Gentle rotation
                gate.mesh.rotation.y += 0.005;

                // 1. Collision Check (near the ship, Z_DESTROY)
                if (gate.mesh.position.z >= SHIP_Z - 0.5 && gate.mesh.position.z <= SHIP_Z + 0.5) {
                    checkCollision(gate);
                }
                
                // 2. Destroy Check (behind the camera)
                if (gate.mesh.position.z > Z_DESTROY) {
                    if (!gate.passed) {
                         // Missing a gate counts as a failure
                         endGame("GATE MISSED!", `You failed to pass through a gate. Final Score: ${score}`);
                         return;
                    }
                    gateContainer.remove(gate.mesh);
                    gates.splice(i, 1);
                }
            }

            // Spawn new gate
            if (performance.now() - lastSpawnTime > spawnInterval) {
                createGate();
                lastSpawnTime = performance.now();
                // Increase spawn frequency over time
                spawnInterval = Math.max(1000, 3000 - score * 10);
            }
        }

        function checkCollision(gate) {
            // Simple check: Is the ship INSIDE the bounds of the hole?
            const shipX = ship.position.x;
            const shipY = ship.position.y;
            const shipRadius = 0.5;

            // Check if the ship has passed the Z plane of the gate
            if (!gate.passed && gate.mesh.position.z >= SHIP_Z) {
                // The hole is centered at gate.mesh.position.x/y and has the size holeRect.width/height
                
                const holeXMin = gate.mesh.position.x - gate.holeRect.width / 2;
                const holeXMax = gate.mesh.position.x + gate.holeRect.width / 2;
                const holeYMin = gate.mesh.position.y - gate.holeRect.height / 2;
                const holeYMax = gate.mesh.position.y + gate.holeRect.height / 2;
                
                // Check if the ship's center is within the hole plus a small margin (shipRadius)
                const safelyThrough = (
                    shipX > holeXMin + shipRadius && 
                    shipX < holeXMax - shipRadius &&
                    shipY > holeYMin + shipRadius &&
                    shipY < holeYMax - shipRadius
                );

                if (safelyThrough) {
                    // Success! Passed through the center
                    gate.passed = true;
                    score += 1;
                    playScoreSound();
                    gate.mesh.material.color.setHex(0x00ff00); // Flash green
                    setTimeout(() => gate.mesh.material.color.setHex(0x10b981), 50);
                } else {
                    // Collision with the ring structure
                    playCollisionSound();
                    endGame("HULL BREACH!", `You clipped the energy gate. Final Score: ${score}`);
                }
            }
        }

        // --- Game Loop ---

        function update() {
            if (!isGameRunning) return;

            // Smoothly interpolate the ship position towards the target position
            ship.position.x += (targetShipPosition.x - ship.position.x) * 0.1;
            ship.position.y += (targetShipPosition.y - ship.position.y) * 0.1;
            
            // Boundary clamping
            ship.position.x = Math.max(-BOUNDARY + ship.geometry.boundingSphere.radius, Math.min(BOUNDARY - ship.geometry.boundingSphere.radius, ship.position.x));
            ship.position.y = Math.max(-BOUNDARY + ship.geometry.boundingSphere.radius, Math.min(BOUNDARY - ship.geometry.boundingSphere.radius, ship.position.y));

            // Update Gates
            updateGates();
            
            // Render
            renderer.render(scene, camera);
            
            updateStatsDisplay();
            animationFrameId = requestAnimationFrame(update);
        }

        // --- UI and Flow Management ---

        function updateStatsDisplay() {
            document.getElementById('score-display').textContent = score;
            document.getElementById('speed-display').textContent = `${gameSpeed.toFixed(1)}x`;
            document.getElementById('status-display').textContent = isGameRunning ? `Drifting at ${gameSpeed.toFixed(1)}x...` : "Ready";
        }

        function updateButtonStates(isStarting) {
            document.getElementById('start-button').disabled = isStarting;
            document.getElementById('stop-button').disabled = !isStarting;

            if (isStarting) {
                 document.getElementById('start-button').textContent = "WARPING...";
                 document.getElementById('stop-button').classList.remove('hidden');
            } else {
                 document.getElementById('start-button').textContent = "Restart Simulation";
                 document.getElementById('stop-button').classList.add('hidden');
            }
        }

        function showMessage(title, message) {
            const modal = document.getElementById('message-modal');
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').innerHTML = message;

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideMessage() {
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('message-modal').classList.remove('flex');
            
            // If hiding the modal initiates the game (from the start screen or after game over)
            if (!isGameRunning && document.getElementById('start-button').textContent === "Start Simulation") {
                startGame();
            }
        }
        
        function resetScene() {
            // Remove all gates
            while(gateContainer.children.length > 0){ 
                gateContainer.remove(gateContainer.children[0]); 
            }
            gates.length = 0;
            ship.position.set(0, 0, SHIP_Z);
            targetShipPosition = { x: 0, y: 0 };
        }

        function endGame(title, message) {
            if (!isGameRunning) return;

            isGameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            showMessage(title, message + `<br><br>Tap to dismiss and restart.`);
            
            updateButtonStates(false);
            updateStatsDisplay();
            renderer.render(scene, camera); // Render final state
        }

        function startGame() {
            initAudio();

            // Reset state
            score = 0;
            gameSpeed = 0.5;
            isGameRunning = true;
            lastSpawnTime = performance.now();
            spawnInterval = 3000;
            
            resetScene(); // Clear all old game objects
            
            // Start the loop
            animationFrameId = requestAnimationFrame(update);
            
            updateButtonStates(true);
            updateStatsDisplay();
        }

        // --- Event Listeners and Initial Setup ---

        window.onload = function() {
            // 1. Initialize 3D scene
            init3D();
            
            // 2. Set up event listeners
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('stop-button').addEventListener('click', () => endGame("MANUAL STOP", `Warp stabilized. Your score: ${score}`));
            
            // 3. Initial UI setup
            updateButtonStates(false);
            updateStatsDisplay();
            // Show start message
            showMessage("Welcome Commander", "Pilot your ship through the energy gates without touching the rings! Speed increases with score.");
            
            // Render initial static scene
            renderer.render(scene, camera);
        };
    </script>
</body>
</html>
