<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Rail Navigator</title>
    <!-- Load Tailwind CSS CDN for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Load Orbitron font for arcade look -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    </style>
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Orbitron', 'sans-serif'],
                    },
                    colors: {
                        'space-dark': '#0f172a', /* slate-900 */
                        'ship-color': '#3b82f6', /* blue-500 */
                        'obstacle-color': '#ef4444', /* red-500 */
                        'rail-color': '#10b981', /* emerald-500 */
                        'highlight': '#fcd34d', /* amber-300 */
                    }
                }
            }
        }
    </script>
    <!-- Custom Game CSS -->
    <style>
        /* Base styles */
        body {
            background-color: #0f172a; 
            color: #fcd34d; 
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none; /* Disable default touch actions for game input */
        }

        /* Canvas Container */
        #game-container {
            width: 95%;
            max-width: 500px;
            margin: 1rem auto;
            border: 5px solid #3b82f6;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.7); 
            border-radius: 8px;
            overflow: hidden;
            background-color: #1e293b; 
        }

        #game-canvas {
            display: block;
            width: 100%;
            touch-action: manipulation;
        }

        /* Button styling */
        .game-button {
            font-size: 1rem;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border: 2px solid #a855f7;
            background: #1f2937;
            color: #a855f7;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
            transition: all 0.15s ease-in-out;
            font-weight: 700;
        }

        .game-button:hover:not(:disabled) {
            background: #a855f7;
            color: #0f172a;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.6);
        }

        .game-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .game-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-center min-h-screen">

    <div class="w-full max-w-4xl flex flex-col items-center">
        <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-rail-color tracking-wider text-shadow-xl text-center">
            ðŸŒŒ QUANTUM RAIL NAVIGATOR âš¡
        </h1>

        <!-- Stats Display -->
        <div class="w-full max-w-[500px] flex justify-between text-lg sm:text-xl font-mono p-3 rounded-lg bg-gray-800 border-2 border-gray-700 shadow-lg mb-4">
            <span>SCORE: <span id="score-display" class="text-highlight">0</span></span>
            <span>SPEED: <span id="speed-display" class="text-ship-color">1.0x</span></span>
        </div>

        <!-- Controls -->
        <div class="flex space-x-4 mb-4">
            <button id="start-button" class="game-button rounded-full">
                Start Warp
            </button>
            <button id="stop-button" class="game-button rounded-full hidden bg-red-800 border-red-500 text-red-300 hover:bg-red-500 hover:text-white" disabled>
                Exit Warp
            </button>
        </div>

        <!-- Game Container -->
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
        </div>
        
        <!-- Status Message -->
        <div class="w-full max-w-[500px] text-center mt-4">
            <p id="status-display" class="text-lg font-bold text-highlight">Press Start to begin navigation!</p>
            <p class="text-xs text-gray-500 mt-1">Use Left/Right Arrow Keys or tap the left/right side of the screen to switch lanes.</p>
        </div>

        <!-- Game Over / Start Message Modal -->
        <div id="message-modal" class="hidden fixed inset-0 bg-space-dark bg-opacity-90 z-20 items-center justify-center" onclick="hideMessage()">
            <div class="bg-gray-800 p-8 rounded-xl shadow-2xl border-4 border-highlight max-w-md w-full mx-4" onclick="event.stopPropagation()">
                <h2 id="modal-title" class="text-3xl font-bold mb-4 text-highlight">Welcome Pilot</h2>
                <p id="modal-message" class="text-gray-300 mb-6 text-lg">Navigate your ship through the quantum rails. Switch lanes to avoid the red energy nodes. Speed increases over time!</p>
                
                <button class="game-button rounded-lg w-full" onclick="hideMessage()">Engage</button>
            </div>
        </div>

        <!-- Signature/Credit -->
        <p class="text-xs text-gray-500 mt-6 tracking-widest uppercase">
            Code Signature: abhijat sarari
        </p>
    </div>

    <!-- JavaScript Game Logic -->
    <script>
        // --- Canvas Setup ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let animationFrameId = null;

        // --- Game State Variables ---
        const NUM_LANES = 3;
        const LANE_PADDING_PERCENT = 0.2; // Padding on left/right edges
        let currentLane = 1; // 0, 1, 2 (Left, Center, Right)
        let obstacles = [];
        let score = 0;
        let gameSpeed = 1.0;
        let lastUpdateTime = 0;
        let obstacleInterval = 1000; // milliseconds
        let lastObstacleTime = 0;
        let isGameRunning = false;
        
        // Ship dimensions (relative to canvas height)
        const SHIP_SIZE_RATIO = 0.1; 
        let shipWidth, shipHeight, shipY;

        // Lane positions
        let laneCenters = [];
        let laneGap; // distance between lane centers

        // --- Tone.js Setup ---
        let moveSynth, collisionSynth, scoreSynth;
        
        function initAudio() {
            try {
                if (!moveSynth) {
                    Tone.start();
                    // Synth for lane change
                    moveSynth = new Tone.Synth().toDestination();
                    moveSynth.set({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.05, sustain: 0 } });
                    
                    // Synth for collision
                    collisionSynth = new Tone.NoiseSynth({ 
                        noise: { type: "white" }, 
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.5 } 
                    }).toDestination();
                    
                    // Synth for scoring (blip)
                    scoreSynth = new Tone.PluckSynth().toDestination();
                }
            } catch (e) {
                console.error("Tone.js failed to initialize:", e);
            }
        }

        function playMoveSound(direction) {
            if (moveSynth) {
                const note = (direction === 'left') ? "C4" : "E4";
                moveSynth.triggerAttackRelease(note, "16n");
            }
        }
        function playCollisionSound() { if (collisionSynth) { collisionSynth.triggerAttackRelease("8n"); } }
        function playScoreSound() { if (scoreSynth) { scoreSynth.triggerAttackRelease("G5", "32n"); } }

        // --- Drawing Functions ---

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const newWidth = container.clientWidth;
            // Maintain a fixed aspect ratio (e.g., 3:4)
            const newHeight = newWidth * 1.5; 
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Recalculate dynamic dimensions based on new width/height
            const padding = newWidth * LANE_PADDING_PERCENT;
            laneGap = (newWidth - 2 * padding) / (NUM_LANES - 1);
            laneCenters = Array.from({ length: NUM_LANES }, (_, i) => padding + i * laneGap);

            shipWidth = newWidth * SHIP_SIZE_RATIO;
            shipHeight = newWidth * SHIP_SIZE_RATIO * 1.5;
            shipY = canvas.height - shipHeight * 1.5;
            
            // Redraw everything if game is running or not
            if (isGameRunning) {
                draw();
            } else {
                drawMenuState();
            }
        }

        function drawTrack() {
            ctx.strokeStyle = tailwind.config.theme.extend.colors['rail-color'];
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 15]); // Dashed line effect

            laneCenters.forEach(center => {
                ctx.beginPath();
                ctx.moveTo(center, 0);
                ctx.lineTo(center, canvas.height);
                ctx.stroke();
            });
            ctx.setLineDash([]); // Reset line dash
        }

        function drawShip() {
            const centerX = laneCenters[currentLane];
            
            // Simplified ship drawing (a triangle)
            ctx.fillStyle = tailwind.config.theme.extend.colors['ship-color'];
            ctx.beginPath();
            ctx.moveTo(centerX, shipY); // Top tip
            ctx.lineTo(centerX - shipWidth / 2, shipY + shipHeight); // Bottom left
            ctx.lineTo(centerX + shipWidth / 2, shipY + shipHeight); // Bottom right
            ctx.closePath();
            ctx.fill();
            
            // Thruster glow (small rectangle below ship)
            ctx.fillStyle = tailwind.config.theme.extend.colors['highlight'];
            ctx.fillRect(centerX - shipWidth * 0.1, shipY + shipHeight, shipWidth * 0.2, shipHeight * 0.2);
        }
        
        function drawObstacle(obstacle) {
            const centerX = laneCenters[obstacle.lane];
            const size = shipWidth * 0.5; // Obstacles are smaller than the ship
            
            ctx.fillStyle = tailwind.config.theme.extend.colors['obstacle-color'];
            ctx.beginPath();
            // Draw a diamond shape (energy node)
            ctx.moveTo(centerX, obstacle.y - size);
            ctx.lineTo(centerX + size, obstacle.y);
            ctx.lineTo(centerX, obstacle.y + size);
            ctx.lineTo(centerX - size, obstacle.y);
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            // 1. Clear Canvas
            ctx.fillStyle = tailwind.config.theme.extend.colors['space-dark'];
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Draw Track
            drawTrack();

            // 3. Draw Ship
            drawShip();

            // 4. Draw Obstacles
            obstacles.forEach(drawObstacle);
            
            if (!isGameRunning) {
                // If game paused/over, darken and display message
                ctx.fillStyle = 'rgba(15, 23, 42, 0.7)'; // Dark overlay
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // drawMenuState(); // Already handled by the modal
            }
        }
        
        function drawMenuState() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['space-dark'];
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = tailwind.config.theme.extend.colors['rail-color'];
            ctx.font = `${canvas.width * 0.08}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.fillText("QUANTUM RAIL", canvas.width / 2, canvas.height / 2 - canvas.height * 0.05);
            ctx.fillText("NAVIGATOR", canvas.width / 2, canvas.height / 2 + canvas.height * 0.05);
        }

        // --- Game Logic ---

        function update(deltaTime) {
            // Update obstacles position
            const moveDistance = gameSpeed * 0.5 * (deltaTime / 16); // Base speed 0.5 units/ms * delta factor
            
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += moveDistance * canvas.height * 0.01; // Scale movement based on canvas size
                
                // Remove if off screen
                if (obs.y > canvas.height) {
                    obstacles.splice(i, 1);
                    score += 10;
                    playScoreSound();
                }
            }

            // Update difficulty (speed and spawn rate)
            gameSpeed = 1.0 + Math.floor(score / 500) * 0.2;
            obstacleInterval = Math.max(500, 1000 - Math.floor(score / 100) * 20);

            // Spawn new obstacle
            if (performance.now() - lastObstacleTime > obstacleInterval) {
                generateObstacle();
                lastObstacleTime = performance.now();
            }
            
            checkCollisions();
            updateStatsDisplay();
        }

        function generateObstacle() {
            const lane = Math.floor(Math.random() * NUM_LANES);
            const y = -20; // Start off screen top
            obstacles.push({ lane, y });
        }
        
        function checkCollisions() {
            const shipRect = {
                x: laneCenters[currentLane] - shipWidth / 2,
                y: shipY,
                width: shipWidth,
                height: shipHeight
            };

            for (const obs of obstacles) {
                const obsSize = shipWidth * 0.5;
                const obsRect = {
                    x: laneCenters[obs.lane] - obsSize,
                    y: obs.y - obsSize,
                    width: obsSize * 2,
                    height: obsSize * 2
                };

                // Simple AABB collision check
                if (shipRect.x < obsRect.x + obsRect.width &&
                    shipRect.x + shipRect.width > obsRect.x &&
                    shipRect.y < obsRect.y + obsRect.height &&
                    shipRect.y + shipRect.height > obsRect.y) 
                {
                    // Collision occurred
                    playCollisionSound();
                    endGame("CRITICAL HIT!", `Your score: ${score}`);
                    return;
                }
            }
        }
        
        // --- Game Loop ---
        function gameLoop(currentTime) {
            if (!isGameRunning) return;

            const deltaTime = currentTime - lastUpdateTime;

            if (deltaTime > 16) { // Aim for ~60 FPS (1000ms / 60 frames)
                update(deltaTime);
                draw();
                lastUpdateTime = currentTime;
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Input Handling ---

        function changeLane(direction) {
            if (!isGameRunning) return;
            
            let newLane = currentLane;
            if (direction === 'left') {
                newLane = Math.max(0, currentLane - 1);
            } else if (direction === 'right') {
                newLane = Math.min(NUM_LANES - 1, currentLane + 1);
            }

            if (newLane !== currentLane) {
                currentLane = newLane;
                playMoveSound(direction);
            }
        }

        function handleKeydown(event) {
            if (event.key === 'ArrowLeft') {
                changeLane('left');
                event.preventDefault();
            } else if (event.key === 'ArrowRight') {
                changeLane('right');
                event.preventDefault();
            }
        }
        
        function handleCanvasClick(event) {
            if (!isGameRunning) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            
            if (clickX < canvas.width / 2) {
                changeLane('left');
            } else {
                changeLane('right');
            }
        }
        
        // --- UI and Flow Management ---

        function updateStatsDisplay() {
            document.getElementById('score-display').textContent = score;
            document.getElementById('speed-display').textContent = `${gameSpeed.toFixed(1)}x`;
            document.getElementById('status-display').textContent = isGameRunning ? "Warp Active..." : "Ready";
        }

        function updateButtonStates(isStarting) {
            document.getElementById('start-button').disabled = isStarting;
            document.getElementById('stop-button').disabled = !isStarting;

            if (isStarting) {
                 document.getElementById('start-button').textContent = "WARPING...";
                 document.getElementById('stop-button').classList.remove('hidden');
            } else {
                 document.getElementById('start-button').textContent = "Restart Warp";
                 document.getElementById('stop-button').classList.add('hidden');
            }
        }

        function showMessage(title, message) {
            const modal = document.getElementById('message-modal');
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').innerHTML = message;

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideMessage() {
            document.getElementById('message-modal').classList.add('hidden');
            document.getElementById('message-modal').classList.remove('flex');
            
            // If hiding the modal initiates the game (from the start screen)
            if (!isGameRunning && score === 0) {
                startGame();
            }
        }
        
        function endGame(title, message) {
            if (!isGameRunning) return;

            isGameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            showMessage(title, message + `<br><br>Press Restart Warp or tap to dismiss this message and restart.`);
            
            updateButtonStates(false);
            updateStatsDisplay();
            draw(); // Final draw state with collision
        }

        function startGame() {
            // Initialize audio on first click interaction
            initAudio();

            // Reset state
            score = 0;
            gameSpeed = 1.0;
            currentLane = 1;
            obstacles = [];
            lastObstacleTime = performance.now();
            isGameRunning = true;
            
            // Start the loop
            lastUpdateTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
            
            updateButtonStates(true);
            updateStatsDisplay();
        }

        // --- Event Listeners and Initial Setup ---

        window.onload = function() {
            // Set up event listeners
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('stop-button').addEventListener('click', () => endGame("MANUAL EXIT", `You safely exited the warp. Your score: ${score}`));
            document.addEventListener('keydown', handleKeydown);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Initial setup
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Show start screen
            updateButtonStates(false);
            updateStatsDisplay();
            showMessage("Welcome Pilot", "Navigate your ship through the quantum rails. Use **Left/Right Arrow Keys** or **Tap the Left/Right side of the screen** to switch lanes and avoid the red energy nodes. Speed increases over time!");
        };
    </script>
</body>
</html>
